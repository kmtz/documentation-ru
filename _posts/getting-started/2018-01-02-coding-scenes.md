---
date: 2018-01-01
title: Coding scenes
description: Данный документ поможет вам разобраться с основами SDK проекта decentraland.
redirect_from:
  - /documentation/introduction/
  - /docs/sdk-overview/
  - /docs/command-line-interface/
  - /docs/sdk-quick-start-guide/
  - /sdk-reference/introduction/
categories:
  - getting-started
type: Document
set: getting-started
set_order: 4
---

## Средства разработки

**Decentraland Software Development Kit** (SDK) позволяет вам делать следующее:

- Сгенерировать базовый проект  _project_ , содержащий сцену Decentraland, включающую все небходимые элементы для отрисовки и последующего запуска.
- Создавайте, тестируйте и просматривайте вашу сцену в веб-браузере - в локальном окружении, без необходимости делать транзакции в сети Ethereum, без необходимости владения участком земли (LAND).
- Пишите на TypeScript, используя API Decentraland и добавляйте динамический контент в вашу сцену..
- Загружайте ваш контент в [IPFS](https://ipfs.io).
- Связывайте ваш земельный участок со ссылкой на ваш контент в IPFS.

SDK включает следующие компоненты:

- **The Decentraland CLI** (Command Line Interface): Используется для создания новых сцен Decentraland в локальном окружении у вас на компьютере, предпросмотра и загрузки в IPFS.
- **The Decentraland API** (ранее известный как _Metaverse API_): Пакет TypeScript, содержащий методы, помогающие создавать интерактивное окружение. Используйте его для создания и манипуляции объектами в сцене, а так же для осуществления внутриигровых транзакций между пользователями и приложениями.

- **Примеры сцен**: Используйте готовые сцены для обучения и изучения [примеров кода]({{ site.baseurl }}{% post_url /examples/2018-01-08-sample-scenes %}).

## Требования

Для разработки сцены в локальном окружении на вашем компьютере вам не нужен собственный участок земли (LAND). Разработка и тестирование происходит в режиме офлайн, без необходимости загружать сцену в сеть Ethereum (система, используемая в Decentraland для управления своим земельным участком,  LAND), или IPFS (P2P сеть, используемая для распределения и доставки контента клиентам).

SDK создан для комфортного использования в терминале. У вас должны быть предустановлены следубщие пакеты:

- **npm** (Node package manager): Используется в терминале для управления зависимостями . [Download link](https://www.npmjs.com/)

- **Редактор исходного кода**: Помогает вам создавать сцены быстро и с меньшим количеством ошибок, так как современные редакторы подсвечивают синтаксические ошибки, умеют автоматически дополнять код и даже показывают вам умные подсказки в зависимости от контекста. Нажмите на объект в коде и вы получите полное описание с методами и аттрибутами, доступными для этого объекта. Мы рекомендуем [Visual Studio Code](https://code.visualstudio.com/) или [Atom](https://atom.io/).

- **The Decentraland CLI**: Используется для создания и загрузки сцен. Смотрите [инструкцию по установке]({{ site.baseurl }}{% post_url /getting-started/2018-01-01-installation-guide %})

## Поддерживаемые языки программирования и синтаксис

#### TypeScript (рекомендуется)

Мы используем [TypeScript (.tsx)](https://www.typescriptlang.org/docs/handbook/jsx.html)для создания сцен.

TypeScript - это расширение JavaScript, так что если вы знакомы с JavaScript, то вы увидите что они очень похожи, однако TypeScript подзоляет вам использовать объектно-ориентированное программирование и строгую типизацию. Дополнительные возможности, такие как автодополнение и проверка типов экономят время, потраченное на разработку и позволяют создавать более надежный и безопасный код. Эти возможности ялвяются ключевыми и помогают создавать более качественный конечный продукт.

В сцене Typescript вы работаете с объектами, которые представляют собой XML код, встроенный в эту сцену. Этот подход очень похож на [React](https://reactjs.org/docs/hello-world.html). Именно поэтому основной файл сцены _scene.tsx_ имеет расширение _.tsx_ ,а не _.ts_.

> **Примечание:** Несмотря на то, что код очень похож на код React, **наш SDK не использует React**.

Смотри [подсказки TypeScript]({{ site.baseurl }}{% post_url /development-guide/2018-01-08-typescript-tips %}) с примерами кода и рекомендациями для разработки в среде Decentraland.

#### XML

Для сцен, в которых используется статичный контент и в которых не будет никаких интерактивных действий, вы можете использовать [XML](https://en.wikipedia.org/wiki/XML).

При создании сцены из CLI выбирайте вариант _Static_.

Мы, в свою очередь, рекомендуем создавать сцены с помощью TypeScript. Сцены TypeScipt включают в себя встроенную разметку XML для описания объектов сцены. Если вы оставите нетронутым весь Typescript код в сцене _Basic_ и будете редактировать только содержимое функции  `render()`, фактически вы будете работать с тем-же XML, только со слегка измененным синтаксисом.

#### Другие языки программирования

Вы можете использовать другие инструменты или языки вместо TypeScript и преобразовывать их в JavaScript, с условимем, что на выхоте у вас будет один файл с именем _scene.js_. Все преобразования типов производятся в TypeScript, другие языки и расширения JS официально не поддерживаются.

## Сцены

Весь контент, который вы создаете для своего участка земли (LAND) называется **сцена**. Сцена - это интерактивная программа, которая отрисовывет содержимое сцены. Это может быть игра, некий интерактивный опыт, графическая галерея, да все что угодно!

Сцены загружаются на участки земли (**parcels**), размером 10х10 метров, уникальные, невзаимозаменяемые цифровые активы, обслуживаемые смарт-контрактами сети Ethereum. Эти участки виртуального пространства - имеено та собственность, куда вы будете загружать контент, созданный с помощью SDK.

Мы разрабатываем веб-клиент, который позволит всем пользователям исследовать мир Decentraland. Весь конткнт, который вы загрузите на ваш участок земли, будет отрисован и доступен с помощью этого клиента. Мы включили инструменты для предпросмотра в SDK, так что сейчас вы можете видеть, тестировать и опробовать ваш контент локально.

## Сущности и компоненты

Сущности - это простейшие элементы, которые вы можете использовать для построения сцен в Decentraland. Можно провести параллели в элементами DOM в веб-разработке.

Трехмерные сцены в  Decentraland основаны на модели [Entity-Component](https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system), где каждый элемент сцены - это некая сущность (_entity_), а каждая сущность может включать компоненты (_components_) , которые описывают ее характеристики и функциональность.

Сущности - это все объекты, которые вы включаете в сцену, то, что в конечном итоге будет видеть пользователь и с чем он будет взаимодействовать в веб-браузере. В это понятие так же включены 3D объекты и аудио файлы.

Компоненты описывают поведение сущностей. Например, вы можете подключить компонент `color` для некой сущности для описания цвета, или добавить компонент `lookAt`, для вращения объекта, чтобы повернуть его к определенной точке в пространстве.

> Примечание: Термин _component_ , который мы используем в описании нашей модели, очень сильно отличается от компонента, который используется в экосистеме _React_, где все является компонентом (_component_). В нашей документации мы будем использовать термин _компонент_(_component_) именно в значении, определяемом в модели сущность-компонент (Entity-Component model).

Сущность может выступать родителем для других сущностей, в этом случае сущности-наследники будут наследовать и компоненты от своего родителя. Если родительский элемент позиционируется, у него меняется размер или он вращается, сущности-наследники так-же будут затронуты. Невидимые сущности так-же могут выступать в качестве объектов-оберток, существующих только для того, чтобы манипулировать группой объектов. Благодаря этому мы можем организовать древовидное наследование.

Почитать подробнее о терминах, определениях и их толкованиях вы можете в нашем [глоссарии]({{ site.baseurl }}{% post_url /general/2018-01-03-glossary %}).

Полная информация о доступных конструкторах для предопределенных сущностей и всех доступных компонентах доступна на странице с описаниями [интерфейсов сущностей (entity interfaces)]({{ site.baseurl }}{% post_url /development-guide/2018-06-21-entity-interfaces %}).

## Функция Render

У всех [объектов сцены]({{ site.baseurl }}{% post_url /development-guide/2018-01-05-scriptable-scene %}) есть функция 'render()` - это метод, который отрисоывает контент, который в итоге увидят пользователи у себя в браузере. Эта функия должна возвращать иерархическую древовидную разметку, корневым элементом которой будет тэг _scene_.

{% raw %}

```tsx
 async render() {
    return (
      <scene position={{ x: 5, y: 0, z: 5 }}>
        <box
          position={{ x: 2, y: 1, z: 0 }}
          scale={{ x: 2, y: 2, z: 0.05 }}
          color="#0000FF"
        />
        <entity
          rotation={this.state.doorRotation}
          transition={{ rotation: { duration: 1000, timing: 'ease-in' } }}
        >
          <box
            id="door"
            scale={{ x: 1, y: 2, z: 0.05 }}
            position={{ x: 0.5, y: 1, z: 0 }}
            color="#00FF00"
          />
        </entity>
      </scene>
    )
  }
```

{% endraw %}

Если у вас есть опыт разработки игр, то возможно вы ожидаете, что сцена непрерывно отрисовывается в цикле. В Decentraland используется другая схема. Наш API основан на _событиях_ (_events_), и метод `render()` обновляет сцену только после некоего события, то есть постоянной отрисовки не происходит.

У сцены есть [состояние]({{ site.baseurl }}{% post_url /development-guide/2018-01-04-scene-state %}), которое представляет собой набор переменных, которые меняются со временем и представляют собой текущее состояние сцены. Состояние сцены меняется в завимимости от [событий]({{ site.baseurl }}{% post_url /development-guide/2018-01-03-event-handling %}), происходящих в сцене. Когда состояние сцены изменяется, происходит вызов метода отрисовки с использованием новых значений переменных.

Подобное поведение есть в [React](https://reactjs.org/), и бОльшая часть информации по React будет так же актуальна и для сцен Decentraland.

## Отделение сцен

Ваши сцены запускаются в отдельном от основного движка контексте (a.k.a. основной поток), они могут даже быть запущены на другом компьютере, не на том, на котором запущен движок Decentralamd. Мы создали наш SDK таким образом, что сцена полностью отделена от движка отрисовки. Такое разделение сделано ради безопасности и быстродействия.

Отделение работает на основе протокола RPC, этот протокол делигирует клиенту только отрисовку сцены и контроль за событиями в сцене.

Мы так-же отделили протокол передачи данных. Это позволяет нам запускать сцены как в локальном окружении, так и удаленно, в окружении сервера Node.js с использованием WebSockets.

Мы не хотим чтобы разработчикам приходилось разбираться с внетренностями движка, им даже не нужно знать как он работает изнутри. Мы должны убедиться, что конечный пользователь получит положительный опыт в мире Decentraland, и что "низкоуровневые" ошибки не будут их касаться

#### Отделение сцены от движка

Давайте рассмотрим пример. Предположим, что вы хотите отрисовать сцену, которая содержит следующий контент::

{% raw %}

```tsx
<scene>
  <gltf-model src="models/a.gltf" />
  <sphere position={{ x: 10, y: 10, z: 10 }} />
</scene>
```

{% endraw %}

Описывая сцену вам не нужно загружать собственно сам файл модели `a.gltf`, вам не нужно знать геометрические координаты всех точек сферы. Все что вым нужно сделать - это описать саму модель в на языке высокого уровня, как вы это делаете в XML.

Как только метод `render()` отправляет сцену движку для отрисовки, движок расчитывает все местоположения, элементы и их геометрию.

Для оптимизации быстродействия, мы отправляем клиенту только изменения в сцене, не всю сцену полностью. Так, если в сцене есть косяк рыб и только одна из них движется, API отправит клиенту только то изменение, которое касается рыбы, которая двигалась. Благодаря этому изменения на стороне клиента происходят быстрее, а для разработчиков такой подход более прозрачен.

## Вдохновляясь кодом React

Одной из целей, которую мы ставили перед собой, при проектировании SDK было максимально облегчить процесс обучения для разработчиком. Мы так же хотели стимулировать разработчиков писать качественный, поддерживаемый код, который соответствует всем стандартам асинсхронного вызова.

Итак, в кратце, существует два общепринятых способа добиться этого:

- **путь jQuery**: мы говорим системе, как обрабытывать, создавать, изменять объекты и тем самым добиваемся желаемого результата.
- **путь React**: мы говорим системе что мы в итоге хотим получить и позволяем ей самой все сделать за нас.

#### Путь _jQuery_ 

Если бы мы выбрали путь jQuery (а мы его не выбрали), то код, который бы описывал нашу сцену выглядел бы примерно так:

{% raw %}

```ts
// WARNING: This code sample is only hypothetical,
// This is not valid syntax
// and is not supported by our tools

let scene = metaverse.createScene()
let objModel = metaverse.createObjModel()
let sphere = metaverse.createSphere()

objModel.setAttribute("src", "models/a.gltf")
objModel.appendTo(scene)

sphere.setAttribute("position", { x: 10, y: 10, z: 10 })
sphere.appendTo(scene)

EntityController.render(scene)
```

{% endraw %}

В этом примере мы говорим системе какие действия нам нужно провести с объектом, чтобы добиться желаемого результата, например нам нужно описать изменения состояния, сторонние эффекты и т.д., чтобы в итоге получить желаемое.

#### Путь _React_

Мы выбрали путь [React](https://reactjs.org/), так что нашу сцену мы опишем следующим кодом:

{% raw %}

```tsx
// IMPORTANT: This code is only an example, it does not exist nor work
 async render() {
   return (
    <scene>
      <obj-model src="models/a.gltf" />
      <sphere position={{ x: 10, y: 10, z: 10 }} />
    </scene>
  )
}
```

{% endraw %}

В этом примере мы просто говорим системе, что мы хотим получить в итоге, не описывая всю логику приложения

Мы создали наш SDK с использованием подхода React по следующим причинам:

- Мы получили все преимущества эволюционирования веб-технологий за последние 10 лет
- Значительно более простой для понимания код, нам не нужно задумываться о шаблонах, которые непосредственно не относятся к бизнес-логике в сцене.
- Этот подход декларативен. Вы описываете **что** вы хотите получить, а не **как** вы добъетесь этого.
- Он помогает быстро разобраться новым разработчикам, уже знакомым с React.
- Этот подход хорошо известен, хорошо документирован и есть множество ресурсов, где можно почерпнуть информацию о нем.
- Подход очень экономно использует память и облегчает работу сборщику мусора.
